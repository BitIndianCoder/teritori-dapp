-Create Indexes
CreateIndex({
  name: "getMultisig",
  source: Collection("Multisig"),
  terms: [
    { field: ["data", "address"]},
    { field: ["data", "chainId"]}
  ]
})

CreateIndex({
  name: "multisig_by_address",
  source: Collection("Multisig"),
  terms: [
    { field: ["data", "address"]}
  ]
})

CreateIndex({
  name: "multisig_by_address_chainid",
  source: Collection("Multisig"),
  terms: [
    { field: ["data", "userAddresses"]}
    { field: ["data", "chainId"]}
  ]
})

CreateIndex({
  name: "multisig_by_useraddress",
  source: Collection("Multisig"),
  terms: [
    { field: ["data", "userAddresses"]}
  ]
})

CreateIndex({
  name: "signature_transaction_by_transaction",
  source: Collection("Signature"),
  terms: [
    { field: ["data", "transaction"]}
  ]
})

CreateIndex({
  name: "transaction_by_address",
  source: Collection("Transaction"),
  terms: [
    { field: ["data", "createdBy"]}
  ]
})

CreateIndex({
  name: "transaction_by_address_type",
  source: Collection("Transaction"),
  terms: [
    { field: ["data", "createdBy"]},
    { field: ["data", "type"]}
  ]
})

CreateIndex({
  name: "transaction_by_multisig_id",
  source: Collection("Transaction"),
  terms: [
    { field: ["data", "multisig"]},
    { field: ["data", "type"]}
  ]
})

CreateIndex({
  name: "transaction_by_multisig_id_notype",
  source: Collection("Transaction"),
  terms: [
    { field: ["data", "multisig"]},
  ]
})

CreateIndex({
  name: "user_wallet",
  source: Collection("UserWallet"),
  terms:[
  { field: ["data", "userAddress"]}
  { field: ["data", "chainId"]}
})

-completeTransaction
Query(
  Lambda(
    ["id", "txHash", "updatedSequence"],
    Update(Ref(Collection("Transaction"), Var("id")), {
      data: { txHash: Var("txHash"), sequence: Var("updatedSequence") }
    })
  )
)

- CreateOrFindMultisig function
Query(
  Lambda(
    ["address", "pubkeyJSON", "chainId", "userAddresses"],
    Let(
      {
        is_multisig: GT(
          Count(
            Match(
              Index("getMultisig"),
              [Var("address"), Var("chainId")]
            )
          ),
          0
        )
      },
      If(
        Var("is_multisig"),
        Select(0, Map(
          Paginate(
            Match(
              Index("getMultisig"),
              [Var("address"), Var("chainId")]
            )
          ),
          Lambda("X", Get(Var("X")))
        ))
        ,
        Create(Collection("Multisig"), {
          data: {
            address: Var("address"),
            chainId: Var("chainId"),
            pubkeyJSON: Var("pubkeyJSON"),
            userAddresses: Var("userAddresses")
          }
        })
      )
    )
  )
)
-getMultisigByUseraddress
Query(
  Lambda(
    ["address"],
    Select(
      ["data"],
      Map(
        Paginate(Match(Index("multisig_by_useraddress"), Var("address"))),
        Lambda("X", Get(Var("X")))
      )
    )
  )


-getMultisigsByUser
Query(
  Lambda(
    ["userAddress", "chainId", "size", "after", "before"],
    Let(
      {
        match: Match(Index("user_wallet"), [
          Var("userAddress"),
          Var("chainId")
        ]),
        page: If(
          Equals(Var("before"), null),
          If(
            Equals(Var("after"), null),
            Paginate(Var("match"), { size: Var("size") }),
            Paginate(Var("match"), { after: Var("after"), size: Var("size") })
          ),
          Paginate(Var("match"), { before: Var("before"), size: Var("size") })
        )
      },
      Map(Var("page"), Lambda("X", Get(Var("X"))))
    )
  )
)
- getTransactionCountByMultisigId
Query(
  Lambda(
    ["id", "types"],
    Map(
      Var("types"),
      Lambda(
        "type",
        Let(
          {
            match: If( Equals(Var("type"), ""),
                    Match(Index("transaction_by_multisig_id_notype"), Ref(Collection("Multisig"), Var("id"))),
                    Match(Index("transaction_by_multisig_id"), [ Ref(Collection("Multisig"), Var("id")), Var("type")])
                  )
          },
          Count(Var("match"))
        )
      )
    )
  )
)

-transactionsByMultisigId
Query(
  Lambda(
    ["id", "type", "size", "after", "before"],
    Let(
      {
        match: If(
          Equals(Var("type"), ""),
          Match(
            Index("transaction_by_multisig_id_notype"),
            Ref(Collection("Multisig"), Var("id"))
          ),
          Match(Index("transaction_by_multisig_id"), [
            Ref(Collection("Multisig"), Var("id")),
            Var("type")
          ])
        ),
        page: If(
          Equals(Var("before"), null),
          If(
            Equals(Var("after"), null),
            Paginate(Var("match"), { size: Var("size") }),
            Paginate(Var("match"), { after: Var("after"), size: Var("size") })
          ),
          Paginate(Var("match"), { before: Var("before"), size: Var("size") })
        )
      },
      Map(Var("page"), Lambda("ref", Get(Var("ref"))))
    )
  )
)

-transactionsByUserAddress
Query(
  Lambda(
    ["address", "type", "size", "after", "before"],
    Let(
      {
        match: If(
          Equals(Var("type"), null),
          Match(Index("transaction_by_address"), Var("address")),
          If(
            Equals(Var("type"), ""),
            Match(Index("transaction_by_address"), Var("address")),
            Match(Index("transaction_by_address_type"), [
              Var("address"),
              Var("type")
            ])
          )
        ),
        page: If(
          Equals(Var("before"), null),
          If(
            Equals(Var("after"), null),
            Paginate(Var("match"), { size: Var("size") }),
            Paginate(Var("match"), { after: Var("after"), size: Var("size") })
          ),
          Paginate(Var("match"), { before: Var("before"), size: Var("size") })
        )
      },
      Map(Var("page"), Lambda("ref", Get(Var("ref"))))
    )
  )
)









